<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;7.&nbsp;Usage</title><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"><link rel="home" href="manual.html" title="Mork"><link rel="up" href="manual.html" title="Mork"><link rel="prev" href="ch06.html" title="Chapter&nbsp;6.&nbsp;Compiling"><link rel="next" href="ch08.html" title="Chapter&nbsp;8.&nbsp;Source Code"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;7.&nbsp;Usage</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch06.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch08.html">Next</a></td></tr></table><hr></div><div class="chapter" title="Chapter&nbsp;7.&nbsp;Usage"><div class="titlepage"><div><div><h2 class="title"><a name="d0e2826"></a>Chapter&nbsp;7.&nbsp;Usage</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="ch07.html#d0e2831">Overview</a></span></dt><dt><span class="sect1"><a href="ch07.html#d0e2861">The <code class="literal">Mapper</code> class</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch07.html#d0e2937">Constructor</a></span></dt><dt><span class="sect2"><a href="ch07.html#d0e3000"><code class="literal">setErrorHander</code></a></span></dt><dt><span class="sect2"><a href="ch07.html#d0e3032"><code class="literal">setEnvironment</code></a></span></dt><dt><span class="sect2"><a href="ch07.html#d0e3044"><code class="literal">run</code></a></span></dt><dt><span class="sect2"><a href="ch07.html#d0e3113"><code class="literal">run</code></a></span></dt></dl></dd><dt><span class="sect1"><a href="ch07.html#d0e3143">The <code class="literal">ErrorHandler</code> interface</a></span></dt><dt><span class="sect1"><a href="ch07.html#d0e3237">Deployment</a></span></dt></dl></div><p>This chapter explains how to work with mapper objects in your applications. The first
      section outlines the most important steps. This is followed by a kind method reference
      of the mapper class. Finally, the last section describes the runtime environment required to
      use a mapper. </p><div class="sect1" title="Overview"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2831"></a>Overview</h2></div></div></div><p>Using a mapper in an application involves creation and running. Suppose the mapper
        name was <code class="literal">foo.Mapper</code>. The following code fragment create a
        <code class="literal">foo.Mapper</code> instance and runs it on the file <code class="literal">xy</code>.
      </p><div class="example"><a name="d0e2845"></a><p class="title"><b>Example&nbsp;7.1.&nbsp;Mapper usage</b></p><div class="example-contents"><pre class="programlisting">
          import net.sf.beezle.mork.mapping.Mapper;

          Mapper mapper;
          Object[] result;
          int i;

          mapper = new Mapper("foo.Mapper");
          result = mapper.run("xy");
          if (result != null) {
          System.out.println("success");
          for (i = 0; i &lt; result.length; i++) {
          System.out.println("\t" + result[i]);
          }
          } else {
          System.out.println("error(s), aborted");
          }
        </pre></div></div><br class="example-break"><p>If the file <code class="literal">xy</code> is mapped without errors, the returned object array
        is printed. Otherwise, <code class="literal">run</code> prints an error message and returns
        <code class="literal">null</code>. Except for Java IO problems, all error messages include the
        current source position.</p></div><div class="sect1" title="The Mapper class"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2861"></a>The <code class="literal">Mapper</code> class</h2></div></div></div><p>The class <code class="literal">net.sf.beezle.mork.mapping.Mapper</code> forms the main API
        used by applications. The following describes the most important constructors and methods.
        This description is sufficient for normal use. See the API documentation for more details.
      </p><p title="Mapper vs. Generated classes"><b><code class="literal">Mapper</code> vs. Generated classes.&nbsp;</b>Note that <code class="literal">Mapper</code> is not a generated classes. How does this class know the
          specific mapping? And what about the classes actually generated by Mork?
          Simple - <code class="literal">Mapper</code> loads the generated classes. <code class="literal">Mapper</code>'s
          purpose is to wrap the generated classes with a fancy API. And to reduce duplicated code since
          major parts of the mapper code do not depend on the specific mapping. The generated classes
          encapsulate the application-specific parts of the code, but the <code class="literal">Mapper</code>
          class hides them from the application.</p><p title="Advanced note"><b>Advanced note.&nbsp;</b>Note that the <code class="literal">Mapper</code> class solves a subtle circular dependency problem.
          Suppose some class <code class="literal">A</code> in some application directly uses a class
          <code class="literal">G</code> generated by running Mork on a mapper file <code class="literal">M</code>. To compile
          <code class="literal">A</code>, <code class="literal">G</code> has to exist, and thus, <code class="literal">M</code> must have
          been compiled. But run Mork on <code class="literal">M</code>, all Java classes <code class="literal">C</code> that
          define constructors referenced from <code class="literal">M</code> must have been compiled. This is a
          circular dependency if <code class="literal">A</code> defines constructors or if there is only a single
          Java-compile step to compile all Java classes. The <code class="literal">Mapper</code> class works around
          this problem by using Java reflection to refer to generated classes. As far as I know, there is no
          performance drawback.</p><p title="Threading"><b>Threading.&nbsp;</b>Mapper objects are not thread-safe. If your code uses multiple threads you have to
          synchronize them to make sure that at most one thread at a time executes within a given mapper
          object. </p><div class="sect2" title="Constructor"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2937"></a>Constructor</h3></div></div></div><p>
          <code class="literal">Mapper(String name)</code>
        </p><p>Instantiates the mapper with the specified name. The <code class="literal">name</code> argument
          specifies the mapper name as defined in the mapper file. You can create any number of mapper
          objects, even instances with the same mapper name. However, most applications will use a single
          mapper object since a given object may be run any number of times.</p><p title="CLASSPATH"><b><code class="literal">CLASSPATH</code>.&nbsp;</b>The specified <code class="literal">name</code> is used to locate the mapper classes generated by
            Mork. Class loading is performed using the class loader that loaded the <code class="literal">Mapper</code>
            class. In most cases, this is the system class loader which searches the class along the
            application's <code class="literal">CLASSPATH</code>. As a result, the same rules for setting the
            <code class="literal">CLASSPATH</code> and placing class files apply to class files generated by Mork and
            class files generated by the Java compiler.</p><p title="Class loading"><b>Class loading.&nbsp;</b>Generated classes a loaded on demand, they are not loaded unless actually used. In most
            cases, they are loaded as part of one of the various <code class="literal">run</code> methods. The purpose
            is to allow applications to instantiate all <code class="literal">Mapper</code> objects they might need
            without wasting time to load classes not actually needed. Time for class loading is an issue
            since generated classes might get quite large.</p><p title="IllegalStateException"><b><code class="literal">IllegalStateException</code>.&nbsp;</b>An <code class="literal">IllegalStateException</code> is thrown if the generated classes cannot be
            loaded (e.g. because of an internal <code class="literal">ClassNotFoundException</code>). Usually, this
            indicates a typo in the specified mapper name or a <code class="literal">CLASSPATH</code> problem. If you
            get an <code class="literal">IllegalStateException</code>, check your <code class="literal">CLASSPATH</code> and make
            sure that the mapper was compiled properly with the appropriate version of Mork. Note: an unchecked
            exception is thrown because the caller is not expected to catch and recover from this problem. I
            can see only good reason for catching the exceptions: to report an internal application error and
            quit.</p></div><div class="sect2" title="setErrorHander"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3000"></a><code class="literal">setErrorHander</code></h3></div></div></div><p><code class="literal">setErrorHandler(net.sf.beezle.mork.mapping.ErrorHandler)</code></p><p>Defines the error handler used by <code class="literal">run</code> to report errors. The
          <code class="literal">ErrorHandler</code> documentation below explains the various types of errors.
        </p><p title="Default error handler"><b>Default error handler.&nbsp;</b>If <code class="literal">setErrorHandler</code> is not used to explicitly define an error handler,
            <code class="literal">run</code> uses a default error handler. The default error handler prints all errors
            to <code class="literal">System.err</code>. All error messages includes the position where the problem
            occurred.  This behavior is sufficient for may applications. Especially if you start with a new
            application, it is save to ignore <code class="literal">setErrorHandler</code> an rely on the default error
            handler. </p></div><div class="sect2" title="setEnvironment"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3032"></a><code class="literal">setEnvironment</code></h3></div></div></div><p><code class="literal">setEnvironment(Object)</code></p><p>Defines the mapper's environment object. Use <code class="literal">YourSymbol : [env];</code> to access
          this object from your mapper file.</p></div><div class="sect2" title="run"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3044"></a><code class="literal">run</code></h3></div></div></div><p><code class="literal">run(Object context, Reader src)</code></p><p>Runs the mapper on the specified stream. <code class="literal">run</code> performs syntactic analysis
          (i.e. scanning and parsing) and mapping into Java objects. If <code class="literal">run</code> does not
          detect errors, it returns the Java objects of the start symbol. The context argument specifies a
          name for the reader, <code class="literal">context.toString()</code> is used to report error positions and
          is typically a file name. The <code class="literal">src</code> argument is internally wrapped by a buffer,
          the is no need to pass some kind of buffered reader.</p><p title="Error handling"><b>Error handling.&nbsp;</b>If <code class="literal">run</code> detects an error (e.g. a syntax errors), this problem is
            reported to the errors handler defined via <code class="literal">setErrorHandler</code>. After reporting
            the error, <code class="literal">run</code> is terminated, returning <code class="literal">null</code> to the caller.
            Note that the first errors terminates <code class="literal">run</code>, there is currently no way to recover,
            mapping result in one error at most.</p><p title="Advanced issues"><b>Advanced issues.&nbsp;</b>(1) A mapper can be run more than once, it is not necessary to create a new mapper to run it
            on a second stream. (2) Run is not thread-save, the caller has to make sure that only one thread
            enters the method at a given time. </p><p title="Unchecked exceptions"><b>Unchecked exceptions.&nbsp;</b><code class="literal">run</code> does not catch unchecked exceptions thrown in constructors. Thus,
            any unchecked exception thrown by a constructor causes the Java virtual machine to terminate
            <code class="literal">run</code> abruptly and propagates the exception o the caller. In my opinion,
            unchecked exceptions should not be catched. Usually, there is no way for an application to recover
            from an unchecked exception because it is either some virtual machine problem (e.g. out of memory)
            or an internal error in the application. In both bases the application should be terminated.
          </p><p title="Cyclic dependencies"><b>Cyclic dependencies.&nbsp;</b><code class="literal">run</code> throws an unchecked exception <code class="literal">CyclicDependencies</code>
            if the attribute grammar used internally has a cyclic dependency. This indicates a problem
            with the mapper specification, not with the stream processed by the mapper. To correct this problem,
            the underlying map file has to be fixed. <code class="literal">CyclicDependencies</code> is an
            unchecked exception because the application has to be fixed, applications are not expected to
            recover from this problem.</p></div><div class="sect2" title="run"><div class="titlepage"><div><div><h3 class="title"><a name="d0e3113"></a><code class="literal">run</code></h3></div></div></div><p><code class="literal">public Object[] run(String fileName)</code></p><p>Convenience method to map files. Opens <code class="literal">fileName</code> as a
          <code class="literal">FileReader</code> and invokes <code class="literal">run(Object context, Reader src)</code>,
          passing <code class="literal">fileName</code> and the <code class="literal">FileReader</code> object as argument.
          As usual, a relative <code class="literal">fileName</code> is interpreted relative to the current working
          directory. The <code class="literal">FileReader</code> object will always be closed when returning from the
          method, even if the mapper throws an unchecked exception. </p></div></div><div class="sect1" title="The ErrorHandler interface"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3143"></a>The <code class="literal">ErrorHandler</code> interface</h2></div></div></div><p><code class="literal">net.sf.beezle.mork.mapping.ErrorHandler</code></p><p>Error handling is work in progress. If you have a choice, please rely on the
        default error handling. Avoid implementing you own error handler since the interface
        is expected to change. Similarly, this documentation is preliminary. It concentrates
        on the various error types (which I consider more stables), it does not explain individual
        methods of the interface. If you have to implement an error handler, the source code of
        <code class="literal">net.sf.beezle.mork.mapping.PrintStreamErrorHandler</code> might provide
        some help.</p><p title="Exceptions"><b>Exceptions.&nbsp;</b><code class="literal">ErrorHandler</code> distinguishes various error types, where each type of error
          reported by a different exception. Different exceptions resemble the various modules involved in
          mapping. Every module reports errors to the <code class="literal">run</code> method by throwing his individual
          exception. <code class="literal">run</code> catches these exceptions and reports them to the registered error
          handler. The following exceptions are distinguished:
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p title="IOException"><b><code class="literal">IOException</code>.&nbsp;</b>Indicates an IO problem in Java's IO classes. These classes feed characters to the
                scanner.</p></li><li class="listitem"><p title="IllegalToken"><b><code class="literal">IllegalToken</code>.&nbsp;</b>Indicates a scanner problem, aka a lexical error.</p></li><li class="listitem"><p title="SyntaxError"><b><code class="literal">SyntaxError</code>.&nbsp;</b>Indicates a parser problem, aka a syntax error.</p></li><li class="listitem"><p title="SemanticError"><b><code class="literal">SemanticError</code>.&nbsp;</b>Indicates a problem while mapping into Java objects, aka a semantic error.
              </p></li></ul></div><p>Note: The terms lexical error, syntax error and semantic error resemble compiler construction
        terminology. These terms are kept even though they conflicts with Java terminology, where
        errors usually indicate a problem in the virtual machine. Both <code class="literal">SyntaxError</code> and
        <code class="literal">SemanticError</code> are derived from Java's <code class="literal">java.lang.Exception</code>
        class.</p><p title="Position"><b>Position.&nbsp;</b><code class="literal">IllegalToken</code>, <code class="literal">SyntaxError</code> and
          <code class="literal">SemanticError</code> have a position field that stores the position in the input
          stream where the problem occurred. The source code for <code class="literal">PrintStreamErrorHandler</code>
          demonstrates how to use this field to report problems to the user.</p><p title="Semantic errors"><b>Semantic errors.&nbsp;</b>A <code class="literal">SemanticError</code> exception is thrown if a constructor invoked
          by the mapper throws a checked exception. <code class="literal">SemanticError</code> has a field
          with the original exception thrown by the constructor and the position of the symbol that
          triggered the constructor. The term semantic error is compiler construction terminology.
          A typical semantic error is an undefined identifier or a type mismatch. Constructors are
          expected to check for semantic errors like undefined identifiers and throw a checked exception
          to indicate problems. </p></div><div class="sect1" title="Deployment"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e3237"></a>Deployment</h2></div></div></div><p>As long as you applications on your development system, you can skip this section:
        all Mork classes needed to run the application have been set up by installing Mork on
        the development system. This section applies if you want to (manually or automatically)
        deploy applications on a system where Mork is not installed.
      </p><p title="Runtime environment"><b>Runtime environment.&nbsp;</b>Two things have to be installed on a system to run an application: a Java runtime
          environment, version 1.2 or higher, and the Mork classes in <code class="literal">lib/mork.jar</code>.
          If the application is executed, Mork classes have to be available in its
          <code class="literal">CLASSPATH</code>. This can be done by globally adding the jar file to the
          <code class="literal">CLASSPATH</code> in some initialization script or by providing an application
          launch script that defines the <code class="literal">CLASSPATH</code> for the application only.
        </p><p title="Optimizations"><b>Optimizations.&nbsp;</b><code class="literal">lib/mork.jar</code> includes quite a few classes that are need by Mork only,
          their are not necessary to run applications. If you want to dig into re-compiling Mork, here
          are some tips how to reduce the size of the jar file.
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Omit classes from the library that are not used by a
              mapper. Most notably, you don't need Mork's
              <code class="literal">compiler</code> and <code class="literal">classfile</code>
              packages. If possible, use a packaging tool to automatically remove
              classes/methods not needed by your application. </p></li><li class="listitem"><p>Re-compile Mork without debug and line number information
              (<code class="literal">javac</code>: omit the -g option, add the -O option).</p></li><li class="listitem"><p>Use a better compiler. For example, Jikes 0.53 produces
              significantly smaller class files than Blackdown JDK 1.2 pre 2 <code class="literal">javac</code>.
            </p></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch06.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch08.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;6.&nbsp;Compiling&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="manual.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;8.&nbsp;Source Code</td></tr></table></div></body></html>