<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;5.&nbsp;Mapper files</title><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"><link rel="home" href="manual.html" title="Mork"><link rel="up" href="manual.html" title="Mork"><link rel="prev" href="ch04.html" title="Chapter&nbsp;4.&nbsp;Syntax files"><link rel="next" href="ch06.html" title="Chapter&nbsp;6.&nbsp;Compiling"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;5.&nbsp;Mapper files</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch06.html">Next</a></td></tr></table><hr></div><div class="chapter" title="Chapter&nbsp;5.&nbsp;Mapper files"><div class="titlepage"><div><div><h2 class="title"><a name="d0e1653"></a>Chapter&nbsp;5.&nbsp;Mapper files</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="ch05.html#d0e1734">Overall structure</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch05.html#d0e1759">Mapper name</a></span></dt><dt><span class="sect2"><a href="ch05.html#d0e1796">Syntax file</a></span></dt><dt><span class="sect2"><a href="ch05.html#d0e1812">Import declarations</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch05.html#d0e1926">Constructors</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch05.html#d0e1964">Normal constructors</a></span></dt><dt><span class="sect2"><a href="ch05.html#d0e2122">Special constructors</a></span></dt><dt><span class="sect2"><a href="ch05.html#d0e2167">Exceptions</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch05.html#d0e2274">Attributes</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch05.html#d0e2296">Definition</a></span></dt><dt><span class="sect2"><a href="ch05.html#d0e2351">Compile-time</a></span></dt><dt><span class="sect2"><a href="ch05.html#d0e2483">Runtime</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch05.html#d0e2539">Visibility</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch05.html#d0e2613">Paths</a></span></dt></dl></dd></dl></div><p title="Mapping"><b>Mapping.&nbsp;</b>Turning input streams into objects is called <span class="emphasis"><em>mapping</em></span>
        <a class="indexterm" name="d0e1664"></a>. Mapping turns data from
        a character representation into an object representation. Initially, data is represented as a
        sequence of characters without structure. This representation is appropriate to edit, store or
        transfer data. In contrast, the object representation the input stream is mapped to is appropriate
        to process the data. For example, numbers are represented by <code class="literal">int</code>s and list are
        represented by <code class="literal">List</code> objects. The purpose of mapping is to turn input streams into
        the representation most appropriate to process the data. Note: the object representation is similar
        to abstract syntax trees generated by some compiler tools, but the classes underlying individual
        objects can be freely chosen and objects are not restricted to trees. </p><div class="figure"><a name="d0e1674"></a><p class="title"><b>Figure&nbsp;5.1.&nbsp;Mapping</b></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="mapping.svg"></object></div></div></div><br class="figure-break"><p title="Steps"><b>Steps.&nbsp;</b>Mapping is comprised of two steps. In step one, the input stream is syntactically analyzed.
        This includes scanning and parsing and results in a syntax tree. This step turns that input
        stream from a character representation into a tree representation. The tree representation is
        used because it's most appropriate to check the syntax of the input stream. Step two takes the
        syntax tree and maps it into objects. This step computed attributes and includes semantic
        analysis like identifier resolution and type checking. </p><p title="Mapper"><b>Mapper.&nbsp;</b>Mapping is performed by an mapper object. A mapper is invoked for an input stream, performs
        scanning, parsing and semantic analysis and returns the objects resulting from the last step.
        A mapper is similar to an <code class="literal">ObjectInputStream</code>, they both kind of de-serializes
        objects and they are both objects themselves. However, a mapper de-serializes from a human-readable
        stream, whereas an <code class="literal">ObjectInputStream</code> de-serialize from an machine-readable stream.
      </p><p title="Mapper files"><b>Mapper files.&nbsp;</b>A mapper file is a text file that defines a mapper.
        <a class="indexterm" name="d0e1701"></a>It defines the syntax of
        an input stream by referencing a syntax file and it defines how to map syntax trees into objects.
        Mork translates mapper files into Java classes. </p><p title="Naming conventions"><b>Naming conventions.&nbsp;</b>Mork does not restrict the name of mapper files. My naming convention for mapper files is
        as follows. The base name is the same as the base name of the syntax file. The file name extension
        is <code class="literal">.mapper</code>. Example: Mork itself has two mappers: <code class="literal">Syntax.mapper</code>
        and <code class="literal">Mapper.mapper</code>.
      </p><p title="Outline"><b>Outline.&nbsp;</b>This chapter is about mapper files. Its sections are structured along the main entities of
        mapper files. A section typically starts with a formal syntax specification, followed by an
        informal description of the respective entity. Sections try to be complete, even if forward
        references are necessary. Note: the full syntax specification for mapper files is given in the
        appendix, the formal syntax specification at the start of a section are taken from this appendix.
      </p><p title="Lexical structure"><b>Lexical structure.&nbsp;</b>Syntax files and mapper files have the same lexical structure. A description was given
        in the previous chapter, it's not repeated here.</p><p title="Meta"><b>Meta.&nbsp;</b>In some sense, syntax files as described in the previous chapter are simple because
        there is nothing special compared to other compiler tools. Defining mapper files should also be
        simple because it is basically a simple association. However, this chapter probably turns out to
        be more difficult because (1) the mapping concept differs from other tools and thus needs
        more explanations and (2) this chapter of the manual is incomplete. </p><div class="sect1" title="Overall structure"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1734"></a>Overall structure</h2></div></div></div><div class="figure"><a name="d0e1737"></a><p class="title"><b>Figure&nbsp;5.2.&nbsp;Overall structure</b></p><div class="figure-contents"><pre class="programlisting">
          Mapper              ::= MapperName SyntaxFile Imports Definitions ;
          MapperName          ::= "mapper" Name ";" ;
          SyntaxFile          ::= "syntax" "=" StringLiteral ";" ;
          Imports             ::= Import* ;
          Import              ::= "import" PackageName ":" Class ("," Class)* ";";
          Class               ::= Identifier ("-&gt;" Identifier)? ;
          PackageName         ::= Name ;
          Name                ::= Identifier ("." Identifier)* ;
        </pre></div></div><br class="figure-break"><p title="Overview"><b>Overview.&nbsp;</b>Start symbol of the mapper file grammar is <code class="literal">Mapper</code>.
          <code class="literal">Definitions</code> form the core of mapper files, they associates symbols
          defined in <code class="literal">SyntaxFile</code> with Java classes declared in
          <code class="literal">Imports</code>.</p><div class="sect2" title="Mapper name"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1759"></a>Mapper name</h3></div></div></div><p title="Purpose"><b>Purpose.&nbsp;</b>The mapper name specifies a fully qualified name for the mapper. The name has to
            follow Java's rules for fully qualified class names. When generating a mapper, the name is used
            as a prefix for the various classes resulting from the generation. When running an application,
            the mapper name is used to locate and load these classes. The name is fully qualified, i.e. the
            mapper package is always included. Thus, the mapper name is like Java package declaration combined
            with a class definition combined into a single statement. </p><p title="File names vs. class names"><b>File names vs. class names.&nbsp;</b>Java distinguishes class names and file names (for class files): A class name is
            not necessarily the name of the class file with the byte code for this class. For example,
            you can define a (non-public) Java class <code class="literal">Foo</code> in a Java file
            <code class="literal">Bar.java</code>. The Java compiler will generate a file <code class="literal">Bar.class</code>
            which defines a class <code class="literal">Foo</code>. Mork implements the same behavior for mappers:
            Defining a mapper <code class="literal">Foo</code> in a mapper file <code class="literal">Bar.mapper</code> results
            in a Java class file <code class="literal">Foo.class</code> defining a class <code class="literal">Bar</code>.
          </p></div><div class="sect2" title="Syntax file"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1796"></a>Syntax file</h3></div></div></div><p title="Syntax File"><b>Syntax File.&nbsp;</b><code class="literal">SyntaxFile</code> refers to the file defining the mapper's syntax.
            <code class="literal">StringLiteral</code> is the file name. A relative file name is interpreted
            relative to the location of the mapper file, not relative to the current directory.
            The character separating directories in the file name is <code class="literal">/</code>, regardless of
            the platform you run Mork on. Thus, it is illegal to use backslashes on Windows. Rationale:
            make mapper file platform independent.</p></div><div class="sect2" title="Import declarations"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1812"></a>Import declarations</h3></div></div></div><p title="Purpose"><b>Purpose.&nbsp;</b><code class="literal">Imports</code> resemble Java import declarations: Import declarations specify
            classes to be referenced by simple identifiers, without the package that contains the class. The
            purpose of both Java and Mork import declarations is to simplify references to classes with long
            qualified names. Qualified names can get quite long, especially because Java naming conventions
            suggest a unique vendor name as part of the package name.</p><p title="Imported classes"><b>Imported classes.&nbsp;</b>An import declaration <code class="literal">import p:X -&gt; Y;</code> (where <code class="literal">p</code> is a
            package name and <code class="literal">X</code> is a simple identifier) declares the imported class
            <code class="literal">Y</code>. The imported class <code class="literal">Y</code> is a reference to the class
            <code class="literal">p.X</code>. <code class="literal">import p:X;</code> is equivalent to
            <code class="literal">import p:X -&gt; X;</code>.</p><p title="Restrictions"><b>Restrictions.&nbsp;</b>To import a class, the following conditions have to be met:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>There is exactly one imported class <code class="literal">Y</code>.
              </p></li><li class="listitem"><p><code class="literal">p.X</code> has been properly compiled and is available
                on the <code class="literal">CLASSPATH</code>.</p></li><li class="listitem"><p><code class="literal">p.X</code> is a class. It is an error to import primitive
                types or interface types.</p></li><li class="listitem"><p><code class="literal">p.X</code> is a public; it must not have private or
                default (i.e. package) visibility.</p></li><li class="listitem"><p>Classes in unnamed packages are not supported. To
                import a class, it has to be member of a package.</p></li><li class="listitem"><p>Nested classes are not supported, only top-level classes
                may be imported.</p></li></ul></div><p title="Document dependencies"><b>Document dependencies.&nbsp;</b>The purpose of Mork import declarations goes beyond Java's import declarations: they are
            meant to document all dependencies of a mapper file. To realize this, mapper files allows to
            reference classes by simple identifiers only, qualified names are not allowed. Thus it is
            impossible to reference a class without mentioning the class in an import declaration.
          </p><p title="No import on demand"><b>No import on demand.&nbsp;</b>In contrast to Java, <code class="literal">import *</code> - aka import on demand - is not
            supported. E.g. Mork rejects <code class="literal">import java.util.*</code>). Rationale for this
            restriction: document dependencies, every class used in a mapper file has to be declared
            explicitly by an import declaration. To reduce the typing resulting from this strategy,
            you can import multiple classes from the same package without repeating the package name.
          </p><p title="No implicit imports"><b>No implicit imports.&nbsp;</b>Mork has nothing like Java's implicit <code class="literal">import java.lang.*</code>.
            Thus, Mork requires an <code class="literal">import java.lang: Integer</code> before the
            <code class="literal">Integer</code> class can be referenced. In addition, classes from the mapper's
            package have to be explicitly imported. Example: <code class="literal">import foo: Bar;</code> is
            required to reference <code class="literal">foo.Bar</code> even if the mapper package is
            <code class="literal">foo</code>. Once again, the rationale is to document dependencies.
          </p></div></div><div class="sect1" title="Constructors"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e1926"></a>Constructors</h2></div></div></div><div class="figure"><a name="d0e1929"></a><p class="title"><b>Figure&nbsp;5.3.&nbsp;Constructors</b></p><div class="figure-contents"><pre class="programlisting">
          Constructor         ::= ClassRef | MemberRef | Internal | Copy;
          ClassRef            ::= Identifier ;
          MemberRef           ::= Identifier "." Identifier ;
          Internal            ::= "[" Identifier "]" ;
          Copy                ::= "(" Identifier ")" ;
        </pre></div></div><br class="figure-break"><p title="Definition"><b>Definition.&nbsp;</b>A constructor creates an object or throws an exception. A constructor is a generalization
          of a Java constructor. It is either a normal constructor or a special constructor. A normal
          constructor is a Java constructor or a Java member (i.e. methods or a fields). Thus, most Java
          classes define a set of constructors. A Java constructor is referenced by its class, a
          member constructor is referenced that a class and an identifier. Note that classes are referenced
          by simple identifiers, qualified class names are not supported. (See the section about import
          declarations for more details).  Besides normal constructors, Mork provides two kind of special
          constructors: internal constructors and copy constructors.
        </p><p title="Unused constructors"><b>Unused constructors.&nbsp;</b>A constructors is invoked even if the result is never used. This is useful if the constructors
          has side-effects (maybe side-effects on arguments), and the return type is void or the result
          is not used.</p><p>A constructor is characterized by its:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>name</p></li><li class="listitem"><p>argument type list</p></li><li class="listitem"><p>result type</p></li><li class="listitem"><p>exceptions</p></li></ul></div><p title="Static typing"><b>Static typing.&nbsp;</b>Argument and return types are known at compile time. This type information is used by
          Mork to perform static type checking. At runtime, all values passed to or returned from a
          constructor are guarantied to be assignable to/from the specified type. It is impossible to
          get runtime type mismatches here because of an illegal constructor invocation.</p><div class="sect2" title="Normal constructors"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1964"></a>Normal constructors</h3></div></div></div><p title="Java constructors"><b>Java constructors.&nbsp;</b></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p title="name"><b>name.&nbsp;</b>A public Java constructor of an imported class <code class="literal">C</code> defines a
                constructor with the name <code class="literal">C</code>.</p></li><li class="listitem"><p title="arguments"><b>arguments.&nbsp;</b><code class="literal">C</code> takes the same arguments as the Java constructor.
              </p></li><li class="listitem"><p title="result"><b>result.&nbsp;</b><code class="literal">C</code> returns the object created by the Java constructor.
              </p></li><li class="listitem"><p title="exceptions"><b>exceptions.&nbsp;</b><code class="literal">C</code> throws all exceptions (both checked and unchecked)
                thrown by the Java constructor.</p></li></ul></div><p title="Java methods"><b>Java methods.&nbsp;</b></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p title="name"><b>name.&nbsp;</b>A public Java method <code class="literal">m</code> of an imported class <code class="literal">C</code>
                defines a constructor with the name <code class="literal">C.m</code>.
              </p></li><li class="listitem"><p title="arguments"><b>arguments.&nbsp;</b><code class="literal">C.m</code> takes the same arguments as the Java method; non-static
                methods take an additional argument of type C as the first argument.
              </p></li><li class="listitem"><p title="result"><b>result.&nbsp;</b><code class="literal">C.m</code> returns the result of the Java method call. For non-static
                methods the constructor invokes the Java method on the object passed as first argument.
              </p></li><li class="listitem"><p title="exceptions"><b>exceptions.&nbsp;</b><code class="literal">C.m</code> throws all exceptions (both checked and unchecked)
                thrown by <code class="literal">C.m</code>.</p></li></ul></div><p title="Java fields"><b>Java fields.&nbsp;</b></p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p title="name"><b>name.&nbsp;</b>A public Java field <code class="literal">F</code> of a imported class <code class="literal">C</code>
                defines a constructor <code class="literal">C.F</code>.</p></li><li class="listitem"><p title="arguments"><b>arguments.&nbsp;</b>If <code class="literal">C.F</code> is a static field, <code class="literal">C.F</code> takes no
                arguments. Otherwise, <code class="literal">C.F</code> takes an argument of type <code class="literal">C</code>.
              </p></li><li class="listitem"><p title="result"><b>result.&nbsp;</b>If <code class="literal">C.F</code> is a static field, <code class="literal">C.F</code> returns the
                value of the static field. Otherwise, <code class="literal">C.F</code> returns the value of the field
                of the argument object.</p></li><li class="listitem"><p title="exceptions"><b>exceptions.&nbsp;</b>C.F throws a <code class="literal">NullPointerException</code> is a non-static field is invoked
                with a null argument.</p></li></ul></div><p title="Example"><b>Example.&nbsp;</b>TODO</p></div><div class="sect2" title="Special constructors"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2122"></a>Special constructors</h3></div></div></div><p title="Internal constructors"><b>Internal constructors.&nbsp;</b>Internal constructors provide access to internal variables maintained by
            the scanner. Only terminal symbols can use internal constructors, it is an error
            to trigger an internal constructor for a non-terminal symbol. Internal constructors
            are specified within array brackets. The following list shows the available
            internal constructors, what the constructor returns and the return type. None of
            these constructors takes arguments and none of these constructors throws exceptions.
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p title="text"><b>text.&nbsp;</b>Returns a string object with the characters of the current terminal
              symbol. For example, <code class="literal">42</code> might be the text returned for an
              <code class="literal">Integer</code> terminal symbol. Return type is String.</p></li><li class="listitem"><p title="ofs"><b><code class="literal">ofs</code>.&nbsp;</b>Returns an Integer value with the current source offset. The first
              offset is 0. Return type is Integer.</p></li><li class="listitem"><p title="line"><b>line.&nbsp;</b>Returns an Integer value with the current source line. The first
              line is 1. Return type is Integer.</p></li><li class="listitem"><p title="column"><b>column.&nbsp;</b>Returns an Integer value with the current source column. The first
              column is 1. Return type is Integer.</p></li></ul></div><p title="Copy constructors"><b>Copy constructors.&nbsp;</b>A copy constructor is specified by a class name within brackets.
            The specified name must be the simple name of a class imported in the
            section header. This notation resembles the Java cast operator. The copy
            constructor does nothing, in particular, no constructor is invoked. Copy
            constructors are useful to work around some argument passing problems.
            Copy constructors should become obsolete by solving these problems.
          </p></div><div class="sect2" title="Exceptions"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2167"></a>Exceptions</h3></div></div></div><p title="Purpose"><b>Purpose.&nbsp;</b>Constructors may throw checked and unchecked exceptions. An unchecked exception
            is an exception derived from <code class="literal">java.lang.RuntimeException</code> or
            <code class="literal">java.lang.Error</code>). Otherwise, it is a checked exception. Technically,
            a constructor may throw exceptions of any type, whenever it sees fit; there are no
            restrictions imposed by Mork. However, I suggest using exceptions as outlines in the
            section.</p><div class="sect3" title="Unchecked exceptions"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2181"></a>Unchecked exceptions</h4></div></div></div><p>Unchecked exceptions should be thrown if a constructor detects an internal error.
            An internal error is something that "should not happen", an inconsistent/unexpected state.
            An internal error can be avoided by the programmer. If not, it's a bug. A
            <code class="literal">NullPointerException</code> usually indicate an internal error. </p><p title="Example"><b>Example.&nbsp;</b><code class="literal">java.lang.Integer.parseInt</code> throws the unchecked exception
              <code class="literal">NumberFormatException</code>. If the mapper syntax imposes the correct
              number syntax on the strings passed to <code class="literal">parseInt</code>, the method can be
              used as a constructor. If a <code class="literal">NumberFormatException</code> occurs, this is a
              bug in the application, because the string passed to <code class="literal">parseInt</code> is
              assumed to be a valid number.</p></div><div class="sect3" title="Checked exceptions"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2208"></a>Checked exceptions</h4></div></div></div><p title="Usage"><b>Usage.&nbsp;</b>A constructor should use checked exceptions to impose constraints on the input.
              Whenever the input (i.e. the arguments passed to the constructors) violates a constraint,
              a checked exception should be thrown. You are free to check whatever constraint you wish.
              A mapper catches checked exceptions and turns the exception's message into an error
              message. Typically, this message is show to the end-user.</p><p title="Semantic errors"><b>Semantic errors.&nbsp;</b>Compiler text books use the term semantic error if some constraint on the input
              stream has been violated. The classic semantic errors are "undefined identifiers" and
              "type mismatches". </p><p title="Example 1"><b>Example 1.&nbsp;</b><code class="literal">java.lang.Class.forName</code> throws the checked exception
              <code class="literal">ClassNotFoundException</code>. When used as a constructor, this is reported
              as a semantic error. </p><p title="Example 2"><b>Example 2.&nbsp;</b>Consider a calculator and an end-user entering the term <code class="literal">1/0</code>. The
              <code class="literal">div</code> method below issues the appropriate error message by throwing
              a <code class="literal">GenericException</code>. (<code class="literal">GenericException</code> is a
              general-purpose checked exception provided by Mork.) Without testing for 0 in the method
              body, the <code class="literal">1/0</code> would result in an internal error of the calculator because
              <code class="literal">left/right</code> would triggers the (unchecked!) exception
              <code class="literal">ArithmeticException</code> if <code class="literal">right == 0</code>.
              </p><pre class="programlisting">
                package foo;

                import net.sf.beezle.mork.util.GenericException;

                public class bar {
                public static int div(int left, int right) throws GenericException {
                if (right == 0) {
                throw new GenericException("division by zero");
                }
                return left/right;
                }
                }
              </pre><p title="Example 2">
            </p><p title="Note"><b>Note.&nbsp;</b>Imposing constrains on constructor arguments sounds like Java's
              <code class="literal">IllegalArgumentExceptions</code>. This exception usually indicates an internal
              error: some Java code has invoked a constructor with illegal arguments. In contrast, a semantic
              error is a checked exception, it is not considered an internal error. The difference to an
              <code class="literal">IllegalArgumentException</code> is, that applications cannot prevent semantic errors:
              arguments are attributes, and attributes stem (directly or indirectly) from end-user's input.
              Unlike Java code, end-user input cannot be controlled by the application. </p></div></div></div><div class="sect1" title="Attributes"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2274"></a>Attributes</h2></div></div></div><p title="Overview"><b>Overview.&nbsp;</b>An attribute associates a symbols with a constructor. A simple attribute is defined
          by <code class="literal">Foo =&gt; Bar</code>, where <code class="literal">Foo</code> is a symbol and
          <code class="literal">Bar</code> is the name of a constructor. Basically, a mapper file is a list of
          attribute definitions, attributes form the core of the file, </p><div class="figure"><a name="d0e2291"></a><p class="title"><b>Figure&nbsp;5.4.&nbsp;Attribute syntax</b></p><div class="figure-contents"><pre class="programlisting">
          Definitions         ::= Group* ;
          Group               ::= Symbol Attribute+ ;
          Symbol              ::= StringSymbol | IdentifierSymbol ;
          StringSymbol        ::= StringLiteral ;
          IdentifierSymbol    ::= Identifier ;
          Attribute           ::= AttributeName "=&gt;" Constructor Visibility;
          AttributeName       ::= (":" Identifier)? ;
        </pre></div></div><br class="figure-break"><div class="sect2" title="Definition"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2296"></a>Definition</h3></div></div></div><p title="Attribute"><b>Attribute.&nbsp;</b>An attribute is defined by (1) a symbol, (2) an attribute name, (3) a constructor
            name and (4) visibility. The attribute is said to be attached to its symbol. Symbol and
            constructor name are most important here, they define the actual mapping. In contrast, it's
            common not to specify an <code class="literal">AttributeName</code> and a <code class="literal">Visibility</code>.
            The constructor name (<code class="literal">Constructor</code>) may be overloaded. For example, a
            constructor name <code class="literal">foo</code> might refer to a constructor
            <code class="literal">foo(String)</code> and <code class="literal">foo(List)</code>.</p><p title="Attribute groups"><b>Attribute groups.&nbsp;</b>Attributes attached to the same symbol may be grouped. This is for your convenience,
            the effect is the same as to isolated attribute definitions.</p><p title="Attribute name"><b>Attribute name.&nbsp;</b><code class="literal">AttributeName</code> defines a name that can be used to refer to the
            attribute in visibility declarations. Every attribute has a name, if it is not supplied
            in the attribute definition, the name defaults to the name of the symbol the attribute is
            attached to. Attribute names have to be unique throughout a mapper file.</p><p title="Main attributes"><b>Main attributes.&nbsp;</b>A main attribute is an attribute whose name equals the name of the symbol it is
            attached to. Since attribute names have to be unique, a given symbol has at most one
            main attribute. Main attributes play a key role in defining implicit visibility.
          </p><p title="Visibility"><b>Visibility.&nbsp;</b><code class="literal">Visibility</code> defines constructors where the attribute is passed as
            an argument.</p><p title="Argument passing"><b>Argument passing.&nbsp;</b>The argument list passed to a constructor is defined by the visibility of all attributes
            defined in a mapper file. This differs from the Java mechanism where arguments are specified
            explicitly by an argument list. </p></div><div class="sect2" title="Compile-time"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2351"></a>Compile-time</h3></div></div></div><p>At compile-time, Mork computes various values for each attribute: the type,
          the argument list, and the constructor.</p><p title="Type"><b>Type.&nbsp;</b>Objects are guaranteed to be of the attribute type. Attribute type is a Java type.
            The type of an attribute is used to perform static type checking and to resolve overloaded
            constructor names. In this sense, the attribute type is similar to the type of a local variable
            in Java. However, the attribute type is not explicitly declared: The type <code class="literal">t</code>
            of an attribute with constructor name <code class="literal">N</code> is computed as follows:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Determine the list <code class="literal">C</code> of all constructors with name
                <code class="literal">N</code>. In may cases, <code class="literal">C</code> has a single element
                only. Otherwise, <code class="literal">N</code> is overloaded.</p></li><li class="listitem"><p>Determine the list <code class="literal">T</code> of all return types of the
                constructors in <code class="literal">C</code>.</p></li><li class="listitem"><p>Replace all primitive types in <code class="literal">T</code> by the
                corresponding wrapper type. For example, replaced <code class="literal">int</code>
                by <code class="literal">Integer</code>.</p></li><li class="listitem"><p>The attribute type <code class="literal">t</code> is the most special Java
                class type that is assignable from each element in <code class="literal">T</code>.
              </p></li></ol></div><p title="Type">
            Notes:
            (1) The attribute type is always a reference type, the above steps never
            result in a primitive type. (2) The attribute type is always a class type,
            the above steps never result in an interface type. Interface types had to be
            excluded because they would introduce ambiguities to the algorithm.
          </p><p title="Example"><b>Example.&nbsp;</b>Consider the attribute <code class="literal">X =&gt; a;</code> and two constructors
            <code class="literal">String a(String)</code> and <code class="literal">int a(int)</code>. The attribute type is
            <code class="literal">Object</code>, because Object is the common supertype of <code class="literal">String</code>
            and <code class="literal">Integer</code>.</p><p title="Argument list"><b>Argument list.&nbsp;</b>The argument list is a list of attributes with cardinality. The visibility
            section describes how the argument list is computed. TODO</p><p title="Attribute constructor"><b>Attribute constructor.&nbsp;</b>An attribute's constructor is obtained by using the argument list to resolve overloaded
            constructor names: A constructor name is resolved to a constructor <code class="literal">F</code> if the
            argument list can be converted to the constructor's argument list. It is an error if there is
            no such <code class="literal">F</code> or if <code class="literal">F</code> is not unique. This is the same mechanism
            used in Java, the argument type decides, if the constructor name is ambiguous.
            Note that overloading is resolved at compile-time, using static type information. It's not
            possible to choose the constructor at runtime, using the actual argument type(s).
          </p><p title="Argument list conversion"><b>Argument list conversion.&nbsp;</b>Argument list conversion adjusts an argument list to match the formal argument list of
            the attribute constructor. Conversion re-orders and unwrap arguments if necessary. The
            conversion algorithm takes a list of actual arguments and transforms it to a list of converted
            arguments:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Choose the first formal argument F of the constructor.
              </p></li><li class="listitem"><p>Choose the leftmost argument A from the actual argument
                list such that A can be converted to F.</p></li><li class="listitem"><p>If no such A is found, the actual argument list cannot
                be converted. Otherwise, remove A from the actual argument list an
                append the converted type for A to the converted argument list.
              </p></li><li class="listitem"><p>Repeat the previous steps for all remaining formal
                arguments.</p></li><li class="listitem"><p>Conversion is succeeds, if all actual arguments have been
                moved to the converted arguments.</p></li></ul></div><p title="Argument list conversion">Argument conversion is explained in the visibility
            section.</p><p title="Argument order"><b>Argument order.&nbsp;</b>A given symbol may have any number of attributes. The ordering of objects
            resulting at runtime follows the ordering of attribute definitions in the mapper file.
            This implies that the array returned from running a mapper is ordered according the
            attribute sequence for the start symbol.</p></div><div class="sect2" title="Runtime"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2483"></a>Runtime</h3></div></div></div><p title="Runtime vs compile-time"><b>Runtime vs compile-time.&nbsp;</b>Symbols and attributes are compile-time entities. They define how to create their
            respective runtime entity: syntax tree nodes and objects. Each syntax tree node has a
            defining symbol, and each object has a defining constructor.</p><p title="Runtime effect"><b>Runtime effect.&nbsp;</b>A syntax tree node for a given symbol <code class="literal">S</code> is mapped into objects by
            invoking the constructors of all attributes attached to <code class="literal">S</code>. Example: an
            attribute <code class="literal">Foo =&gt; Bar;</code> defines that the symbol <code class="literal">Foo</code> is
            mapped to the object returned by the constructor <code class="literal">Bar</code>. Whenever a mapper
            identifies a <code class="literal">Foo</code> syntax tree node, the <code class="literal">Bar</code> constructor
            is invoked. The constructor returns an object which is passes to other constructors as
            defined by the attributes visibility.</p><p title="Runtime effect"><b>Runtime effect.&nbsp;</b>At runtime, syntax tree nodes are mapped into objects. Consider a symbol
            <code class="literal">S</code>. At runtime, each syntax tree node of <code class="literal">S</code> is
            augmented with the objects that result from invoking all constructors
            triggered for symbol. </p><p title="Wrapper objects"><b>Wrapper objects.&nbsp;</b>If a constructor returns a primitive value, this is automatically wrapped by the
            appropriate wrapper object. This wrapping is reflected in the above rules to compute the
            attribute type. For example, <code class="literal">int</code> values are wrapped by
            <code class="literal">Integer</code> objects. Automatic wrapping corresponds with automatic
            unwrapping for constructor arguments. In effect, wrapping and unwrapping is transparent
            for constructor definitions. Within Java code, you can freely choose to work with primitive
            values or wrapper values. </p></div></div><div class="sect1" title="Visibility"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2539"></a>Visibility</h2></div></div></div><p>Mork uses visibilities rules because most of the argument passing is trivial and known
        implicitly. Visibility rules just specify where trivial argument passing does not apply.
      </p><p>TODO: This section is a collection of fragments.
        Visibility is very experimental and subject to change.</p><div class="figure"><a name="d0e2546"></a><p class="title"><b>Figure&nbsp;5.5.&nbsp;Visibility syntax</b></p><div class="figure-contents"><pre class="programlisting">
          Visibility          ::= Implicit | Explicit ;
          Implicit            ::= ";" ;
          Explicit            ::= ":" ("&gt;" Path)* ";" ;
        </pre></div></div><br class="figure-break"><p>
        Visibility defines to what constructor an object is passed as an argument.
        It is specified by modifiers and a list of views. Most argument
        passing is specified by modifiers, paths deals with special situations.
      </p><p title="Empty visibility"><b>Empty visibility.&nbsp;</b>The constructor of an attribute is invoked, even if it has an empty explicit visibility.
          Empty explicit visibility is useful if the constructor has side-effects on its arguments.
        </p><p title="Argument types and argument values"><b>Argument types and argument values.&nbsp;</b>An argument type is not the same as a Java type, because an argument
          value is not (always) the same as a Java value! In fact, any number of Java
          values might make up a single argument value. In many cases, an argument
          value is comprised of exactly one Java value. However, argument values
          can consist of a list of objects. In order to encode this, the argument type
          is comprised of two elements: a component type and a cardinality.
        </p><p title="Component type"><b>Component type.&nbsp;</b>The component type is a Java reference type, for example String or
          Object. Each individual Java value within an argument value is assignable
          to the component type. Note that the component type can not be a Java
          primitive type like int or boolean. This is not a restriction because Mork
          automatically uses wrapper classes. Note also, that reference types include
          both arrays of primitive types and arrays of reference types. The Java
          language defines arrays to be reference types.</p><p title="Cardinality"><b>Cardinality.&nbsp;</b>The cardinality determines how many Java values make up an
          argument value. </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p title="value"><b>value.&nbsp;</b>Exactly one Java value. In this manual, C:1 denotes an argument
            type with component type C and value cardinality.</p></li><li class="listitem"><p title="option"><b>option.&nbsp;</b>None or one Java value. In this manual, C:? denotes an argument
            type with component type C and option cardinality.</p></li><li class="listitem"><p title="sequence"><b>sequence.&nbsp;</b>Any number of Java values, including zero. In this manual, C:*
            denotes an argument type with component type C and sequence cardinality.
          </p></li></ul></div><p title="Conversion"><b>Conversion.&nbsp;</b>Mappers pass argument values around, but constructors are defined
          by Java programs and operate on Java objects. Constructors take Java values
          as arguments and they return Java values as results. Thus, a mapper has
          to convert between attribute values and Java values when transferring values
          to and from constructors. The rules for these conversions are described in
          the constructors section. </p><p title="Argument conversion"><b>Argument conversion.&nbsp;</b>Arguments are passed to constructors, which includes argument conversion.
          At runtime, argument conversion might unwrap objects and create arrays
          or lists. An argument A can be converted to a formal argument F if:
          </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>A has value or option cardinality and F is assignable from the
                component type of A.</p></li><li class="listitem"><p>A has value or option cardinality and F is a primitive type
                and the wrapper type for F is assignable from the component type of A.
              </p></li><li class="listitem"><p>A has sequence cardinality and F is a assignable from a Java List
                or F is assignable from the array type for the component type.</p></li></ul></div><p title="Argument conversion">
        </p><div class="sect2" title="Paths"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2613"></a>Paths</h3></div></div></div><p>TODO: this section is a collection of fragments. Paths are still evolving and
          subject to change.</p><p title="Purpose"><b>Purpose.&nbsp;</b>Paths declare non-local visibility. They are special in two ways:
            (1) a single path can select multiple values, and (2) paths can access
            remote values.</p><div class="figure"><a name="d0e2623"></a><p class="title"><b>Figure&nbsp;5.6.&nbsp;Path syntax</b></p><div class="figure-contents"><pre class="programlisting">
            Path                ::= ImplicitPath | LocalPath | NormalPath ;
            ImplicitPath        ::= "\\\\*" ;
            LocalPath           ::= Identifier ;
            NormalPath          ::= Step+ ;
            Step                ::= Move Identifier ;
            Move                ::= Ups | Up | Downs | Down ;
            Ups                 ::= "\\\\" ;
            Up                  ::= "\\" ;
            Downs               ::= "//" ;
            Down                ::= "/" ;
          </pre></div></div><br class="figure-break"><p title="Paths"><b>Paths.&nbsp;</b>A path is a sequence of steps, where a step is comprised of a move
            and an identifier. The last identifier within a path is specifies an
            attribute, all other identifiers specify symbols. The context of a path
            is the attribute symbol, the path is used in.</p><p title="Move"><b>Move.&nbsp;</b>Move specify how to move in the syntax tree. Up and down moves
            (<code class="literal">\</code> and <code class="literal">/</code>) specify a single step, ups and
            downs moves (<code class="literal">\\</code> and <code class="literal">//</code>) specify repeated steps.
          </p><p title="Dead-end paths"><b>Dead-end paths.&nbsp;</b>A dead-end path is a path that does not reach any attributes, i.e. that does
            not actually contribute to the visibility. <a class="indexterm" name="d0e2655"></a>
            It is an error to specify dead-end paths. Example: <code class="literal">/X</code> if a dead-end path when
            applied to a symbol <code class="literal">Y ::= Z Z; </code>. TODO: what about the start symbols?
          </p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch06.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;4.&nbsp;Syntax files&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="manual.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;6.&nbsp;Compiling</td></tr></table></div></body></html>